import { test, expect } from '@playwright/test'
import { CanvasHelpers, EventAPIHelpers } from './helpers/canvas-helpers'
import { CANVAS_SELECTORS, mockEvents } from '../fixtures/canvas'

/**
 * E2E Tests for Canvas Event Sourcing Integration (Task 5.1)
 * Test ID: E2E-CV-EVENTS
 * 
 * This test suite covers Canvas event sourcing functionality:
 * - Canvas state changes are recorded as events
 * - Pan/zoom state persists across page reloads
 * - Undo/redo works for canvas operations
 * - Event ordering and integrity
 * 
 * Following TDD approach - these tests will FAIL initially.
 */

test.describe('Canvas Component - Event Recording', () => {
  let canvasHelpers: CanvasHelpers
  let eventHelpers: EventAPIHelpers

  test.beforeEach(async ({ page }) => {
    canvasHelpers = new CanvasHelpers(page)
    eventHelpers = new EventAPIHelpers(page)
    
    await canvasHelpers.initializeCanvas()
    await canvasHelpers.focusCanvas()
  })

  test('should record PAN_CANVAS events [E2E-CV-EVENT-01]', async ({ page }) => {
    // Test ID: E2E-CV-EVENT-01
    // PRD Reference: Pan operations must be recorded in event log
    
    // Perform pan operation
    await canvasHelpers.panCanvas({ x: 100, y: 50 })
    
    // Wait for event to be recorded
    const panEvent = await eventHelpers.waitForEvent('PAN_CANVAS', 3000)
    
    // Verify event structure
    eventHelpers.verifyEventStructure(panEvent)
    expect(panEvent.type).toBe('PAN_CANVAS')
    
    // Verify event payload contains pan information
    expect(panEvent.payload).toBeTruthy()
    expect(panEvent.payload.fromViewBox).toBeTruthy()
    expect(panEvent.payload.toViewBox).toBeTruthy()
    expect(typeof panEvent.payload.deltaX).toBe('number')
    expect(typeof panEvent.payload.deltaY).toBe('number')
  })

  test('should record ZOOM_CANVAS events [E2E-CV-EVENT-02]', async ({ page }) => {
    // Test ID: E2E-CV-EVENT-02
    // PRD Reference: Zoom operations must be recorded in event log
    
    // Perform zoom operation
    await canvasHelpers.zoomCanvas('in', 2)
    
    // Wait for event to be recorded
    const zoomEvent = await eventHelpers.waitForEvent('ZOOM_CANVAS', 3000)
    
    // Verify event structure
    eventHelpers.verifyEventStructure(zoomEvent)
    expect(zoomEvent.type).toBe('ZOOM_CANVAS')
    
    // Verify event payload contains zoom information\n    expect(zoomEvent.payload).toBeTruthy()\n    expect(typeof zoomEvent.payload.fromScale).toBe('number')\n    expect(typeof zoomEvent.payload.toScale).toBe('number')\n    expect(zoomEvent.payload.fromViewBox).toBeTruthy()\n    expect(zoomEvent.payload.toViewBox).toBeTruthy()\n    expect(zoomEvent.payload.zoomCenter).toBeTruthy()\n  })\n\n  test('should record RESET_VIEW events [E2E-CV-EVENT-03]', async ({ page }) => {\n    // Test ID: E2E-CV-EVENT-03\n    // PRD Reference: View reset operations must be recorded\n    \n    // Modify view first\n    await canvasHelpers.panCanvas({ x: 50, y: 50 })\n    await canvasHelpers.zoomCanvas('in', 1)\n    \n    // Reset view\n    await canvasHelpers.resetView()\n    \n    // Wait for reset event\n    const resetEvent = await eventHelpers.waitForEvent('RESET_VIEW', 3000)\n    \n    // Verify event structure\n    eventHelpers.verifyEventStructure(resetEvent)\n    expect(resetEvent.type).toBe('RESET_VIEW')\n    \n    // Verify event payload\n    expect(resetEvent.payload).toBeTruthy()\n    expect(resetEvent.payload.fromViewBox).toBeTruthy()\n    expect(resetEvent.payload.fromScale).toBeTruthy()\n    expect(resetEvent.payload.trigger).toBeTruthy() // 'keyboard', 'button', etc.\n  })\n\n  test('should include user context in events [E2E-CV-EVENT-04]', async ({ page }) => {\n    // Test ID: E2E-CV-EVENT-04\n    // PRD Reference: Events should include user identification\n    \n    // Perform an operation that generates an event\n    await canvasHelpers.panCanvas({ x: 25, y: 25 })\n    \n    // Get the event\n    const panEvent = await eventHelpers.waitForEvent('PAN_CANVAS')\n    \n    // Verify user context is included\n    expect(panEvent.userId).toBeTruthy()\n    expect(typeof panEvent.userId).toBe('string')\n    \n    // Verify session/context information\n    expect(panEvent.timestamp).toBeTruthy()\n    const timestamp = new Date(panEvent.timestamp)\n    expect(timestamp.getTime()).not.toBeNaN()\n  })\n\n  test('should maintain event ordering [E2E-CV-EVENT-05]', async ({ page }) => {\n    // Test ID: E2E-CV-EVENT-05\n    // PRD Reference: Events should be ordered by timestamp\n    \n    // Perform multiple operations in sequence\n    await canvasHelpers.panCanvas({ x: 10, y: 10 })\n    await page.waitForTimeout(100)\n    await canvasHelpers.zoomCanvas('in', 1)\n    await page.waitForTimeout(100)\n    await canvasHelpers.panCanvas({ x: -5, y: -5 })\n    \n    // Get all canvas events\n    await page.waitForTimeout(500) // Allow events to be processed\n    const allEvents = await eventHelpers.getAllEvents()\n    \n    // Filter canvas-related events\n    const canvasEvents = allEvents.filter(event => \n      ['PAN_CANVAS', 'ZOOM_CANVAS', 'RESET_VIEW'].includes(event.type)\n    )\n    \n    expect(canvasEvents.length).toBeGreaterThanOrEqual(3)\n    \n    // Verify timestamp ordering\n    for (let i = 1; i < canvasEvents.length; i++) {\n      const prevTime = new Date(canvasEvents[i-1].timestamp).getTime()\n      const currTime = new Date(canvasEvents[i].timestamp).getTime()\n      expect(currTime).toBeGreaterThanOrEqual(prevTime)\n    }\n  })\n\n  test('should handle rapid event generation [E2E-CV-EVENT-06]', async ({ page }) => {\n    // Test ID: E2E-CV-EVENT-06\n    // PRD Reference: System should handle rapid user interactions\n    \n    const startTime = Date.now()\n    \n    // Generate multiple events rapidly\n    for (let i = 0; i < 5; i++) {\n      await canvasHelpers.panCanvas({ x: i * 5, y: i * 3 })\n      await page.waitForTimeout(50)\n    }\n    \n    const endTime = Date.now()\n    \n    // Operations should complete reasonably quickly\n    expect(endTime - startTime).toBeLessThan(2000)\n    \n    // All events should be recorded\n    await page.waitForTimeout(500)\n    const panEvents = await eventHelpers.getEventsByType('PAN_CANVAS')\n    expect(panEvents.length).toBeGreaterThanOrEqual(5)\n  })\n})\n\ntest.describe('Canvas Component - State Persistence', () => {\n  let canvasHelpers: CanvasHelpers\n  let eventHelpers: EventAPIHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    eventHelpers = new EventAPIHelpers(page)\n    \n    await canvasHelpers.initializeCanvas()\n    await canvasHelpers.focusCanvas()\n  })\n\n  test('should persist canvas state across page reloads [E2E-CV-PERSIST-01]', async ({ page }) => {\n    // Test ID: E2E-CV-PERSIST-01\n    // PRD Reference: Canvas state should persist between sessions\n    \n    // Set a specific view state\n    await canvasHelpers.panCanvas({ x: 75, y: 50 })\n    await canvasHelpers.zoomCanvas('in', 2)\n    await page.waitForTimeout(300)\n    \n    // Record the current state\n    const beforeReloadViewBox = await canvasHelpers.getViewBox()\n    \n    // Reload the page\n    await page.reload()\n    await page.waitForLoadState('networkidle')\n    \n    // Re-initialize helpers\n    await canvasHelpers.initializeCanvas()\n    \n    // Check if state was restored\n    const afterReloadViewBox = await canvasHelpers.getViewBox()\n    \n    // State should be similar (within reasonable tolerance for floating point)\n    expect(Math.abs(afterReloadViewBox.x - beforeReloadViewBox.x)).toBeLessThan(5)\n    expect(Math.abs(afterReloadViewBox.y - beforeReloadViewBox.y)).toBeLessThan(5)\n    expect(Math.abs(afterReloadViewBox.width - beforeReloadViewBox.width)).toBeLessThan(5)\n    expect(Math.abs(afterReloadViewBox.height - beforeReloadViewBox.height)).toBeLessThan(5)\n  })\n\n  test('should restore canvas state from event log [E2E-CV-PERSIST-02]', async ({ page }) => {\n    // Test ID: E2E-CV-PERSIST-02\n    // PRD Reference: Canvas state should be reconstructed from events\n    \n    // Perform operations to generate events\n    await canvasHelpers.panCanvas({ x: 30, y: 20 })\n    await page.waitForTimeout(100)\n    await canvasHelpers.zoomCanvas('out', 1)\n    await page.waitForTimeout(100)\n    \n    // Get events that were generated\n    const initialEvents = await eventHelpers.getAllEvents()\n    const canvasEvents = initialEvents.filter(event => \n      ['PAN_CANVAS', 'ZOOM_CANVAS'].includes(event.type)\n    )\n    \n    expect(canvasEvents.length).toBeGreaterThanOrEqual(2)\n    \n    // Events should contain enough information to reconstruct state\n    const lastPanEvent = canvasEvents.find(e => e.type === 'PAN_CANVAS')\n    const lastZoomEvent = canvasEvents.find(e => e.type === 'ZOOM_CANVAS')\n    \n    if (lastPanEvent) {\n      expect(lastPanEvent.payload.toViewBox).toBeTruthy()\n    }\n    \n    if (lastZoomEvent) {\n      expect(lastZoomEvent.payload.toViewBox).toBeTruthy()\n      expect(typeof lastZoomEvent.payload.toScale).toBe('number')\n    }\n  })\n\n  test('should handle state conflicts gracefully [E2E-CV-PERSIST-03]', async ({ page }) => {\n    // Test ID: E2E-CV-PERSIST-03\n    // PRD Reference: System should handle concurrent state changes\n    \n    // This test simulates potential race conditions or conflicts\n    // In a real scenario, this might involve multiple browser tabs\n    \n    // Perform rapid state changes\n    await canvasHelpers.panCanvas({ x: 100, y: 0 })\n    await canvasHelpers.zoomCanvas('in', 3)\n    await canvasHelpers.panCanvas({ x: -50, y: 50 })\n    \n    // Verify final state is consistent\n    const finalViewBox = await canvasHelpers.getViewBox()\n    \n    // State should be valid\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n    expect(isNaN(finalViewBox.x)).toBe(false)\n    expect(isNaN(finalViewBox.y)).toBe(false)\n  })\n})\n\ntest.describe('Canvas Component - Undo/Redo Functionality', () => {\n  let canvasHelpers: CanvasHelpers\n  let eventHelpers: EventAPIHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    eventHelpers = new EventAPIHelpers(page)\n    \n    await canvasHelpers.initializeCanvas()\n    await canvasHelpers.focusCanvas()\n  })\n\n  test('should support undo operations [E2E-CV-UNDO-01]', async ({ page }) => {\n    // Test ID: E2E-CV-UNDO-01\n    // PRD Reference: Canvas operations should be undoable\n    \n    // Record initial state\n    const initialViewBox = await canvasHelpers.getViewBox()\n    \n    // Perform an operation\n    await canvasHelpers.panCanvas({ x: 100, y: 75 })\n    await page.waitForTimeout(200)\n    \n    const modifiedViewBox = await canvasHelpers.getViewBox()\n    expect(modifiedViewBox.x).not.toBe(initialViewBox.x)\n    \n    // Perform undo with Ctrl+Z\n    await page.keyboard.press('Control+KeyZ')\n    await page.waitForTimeout(300)\n    \n    // State should be reverted\n    const undoViewBox = await canvasHelpers.getViewBox()\n    expect(Math.abs(undoViewBox.x - initialViewBox.x)).toBeLessThan(5)\n    expect(Math.abs(undoViewBox.y - initialViewBox.y)).toBeLessThan(5)\n    \n    // Verify UNDO event was created\n    const undoEvent = await eventHelpers.waitForEvent('UNDO', 2000)\n    expect(undoEvent.type).toBe('UNDO')\n  })\n\n  test('should support redo operations [E2E-CV-UNDO-02]', async ({ page }) => {\n    // Test ID: E2E-CV-UNDO-02\n    // PRD Reference: Undone operations should be redoable\n    \n    // Perform operation\n    await canvasHelpers.zoomCanvas('in', 2)\n    await page.waitForTimeout(200)\n    \n    const zoomedViewBox = await canvasHelpers.getViewBox()\n    \n    // Undo the operation\n    await page.keyboard.press('Control+KeyZ')\n    await page.waitForTimeout(200)\n    \n    const undoViewBox = await canvasHelpers.getViewBox()\n    expect(undoViewBox.width).not.toBe(zoomedViewBox.width)\n    \n    // Redo with Ctrl+Y\n    await page.keyboard.press('Control+KeyY')\n    await page.waitForTimeout(300)\n    \n    // State should be restored to after-zoom state\n    const redoViewBox = await canvasHelpers.getViewBox()\n    expect(Math.abs(redoViewBox.width - zoomedViewBox.width)).toBeLessThan(5)\n    expect(Math.abs(redoViewBox.height - zoomedViewBox.height)).toBeLessThan(5)\n    \n    // Verify REDO event was created\n    const redoEvent = await eventHelpers.waitForEvent('REDO', 2000)\n    expect(redoEvent.type).toBe('REDO')\n  })\n\n  test('should handle multiple undo/redo operations [E2E-CV-UNDO-03]', async ({ page }) => {\n    // Test ID: E2E-CV-UNDO-03\n    // PRD Reference: Multiple operations should be undoable in sequence\n    \n    const initialViewBox = await canvasHelpers.getViewBox()\n    \n    // Perform multiple operations\n    await canvasHelpers.panCanvas({ x: 50, y: 0 })\n    await page.waitForTimeout(100)\n    const step1ViewBox = await canvasHelpers.getViewBox()\n    \n    await canvasHelpers.panCanvas({ x: 0, y: 50 })\n    await page.waitForTimeout(100)\n    const step2ViewBox = await canvasHelpers.getViewBox()\n    \n    await canvasHelpers.zoomCanvas('in', 1)\n    await page.waitForTimeout(100)\n    const step3ViewBox = await canvasHelpers.getViewBox()\n    \n    // Undo all operations\n    await page.keyboard.press('Control+KeyZ')\n    await page.waitForTimeout(150)\n    const undo1ViewBox = await canvasHelpers.getViewBox()\n    \n    await page.keyboard.press('Control+KeyZ')\n    await page.waitForTimeout(150)\n    const undo2ViewBox = await canvasHelpers.getViewBox()\n    \n    await page.keyboard.press('Control+KeyZ')\n    await page.waitForTimeout(150)\n    const undo3ViewBox = await canvasHelpers.getViewBox()\n    \n    // Should be back to initial state\n    expect(Math.abs(undo3ViewBox.x - initialViewBox.x)).toBeLessThan(5)\n    expect(Math.abs(undo3ViewBox.y - initialViewBox.y)).toBeLessThan(5)\n    \n    // Verify multiple UNDO events\n    const undoEvents = await eventHelpers.getEventsByType('UNDO')\n    expect(undoEvents.length).toBeGreaterThanOrEqual(3)\n  })\n\n  test('should show undo/redo availability indicators [E2E-CV-UNDO-04]', async ({ page }) => {\n    // Test ID: E2E-CV-UNDO-04\n    // PRD Reference: UI should indicate when undo/redo is available\n    \n    // Initially, there might not be undo/redo indicators visible\n    // This depends on implementation - look for visual indicators\n    \n    // Perform an operation to make undo available\n    await canvasHelpers.panCanvas({ x: 25, y: 25 })\n    await page.waitForTimeout(200)\n    \n    // Look for undo/redo UI indicators\n    // These might be buttons, tooltips, or text indicators\n    const undoIndicator = page.locator('[data-testid*=\"undo\"], .undo, [title*=\"undo\" i], [aria-label*=\"undo\" i]')\n    const redoIndicator = page.locator('[data-testid*=\"redo\"], .redo, [title*=\"redo\" i], [aria-label*=\"redo\" i]')\n    \n    // At least some form of undo indication should be present\n    const undoVisible = await undoIndicator.count() > 0\n    const hasUndoHint = await page.locator('text=/undo|Ctrl\\+Z/i').count() > 0\n    \n    expect(undoVisible || hasUndoHint).toBeTruthy()\n  })\n\n  test('should handle undo/redo limits [E2E-CV-UNDO-05]', async ({ page }) => {\n    // Test ID: E2E-CV-UNDO-05\n    // PRD Reference: System should handle undo/redo stack limits gracefully\n    \n    // This test checks behavior when undo/redo limits are reached\n    // Generate many operations\n    for (let i = 0; i < 10; i++) {\n      await canvasHelpers.panCanvas({ x: i * 2, y: i })\n      await page.waitForTimeout(50)\n    }\n    \n    // Try to undo more operations than available\n    for (let i = 0; i < 15; i++) {\n      await page.keyboard.press('Control+KeyZ')\n      await page.waitForTimeout(30)\n    }\n    \n    // Canvas should remain in valid state\n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n    expect(isNaN(finalViewBox.x)).toBe(false)\n    expect(isNaN(finalViewBox.y)).toBe(false)\n  })\n})"