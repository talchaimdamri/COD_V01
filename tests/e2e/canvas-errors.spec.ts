import { test, expect } from '@playwright/test'
import { CanvasHelpers, EventAPIHelpers } from './helpers/canvas-helpers'
import { CANVAS_SELECTORS, errorScenarios } from '../fixtures/canvas'

/**
 * E2E Tests for Canvas Error Handling (Task 5.1)
 * Test ID: E2E-CV-ERRORS
 * 
 * This test suite covers Canvas error scenarios and edge cases:
 * - Network errors and API failures
 * - Invalid input handling
 * - Boundary condition errors
 * - Recovery mechanisms
 * 
 * Following TDD approach - these tests will FAIL initially.
 */

test.describe('Canvas Component - Network and API Error Handling', () => {
  let canvasHelpers: CanvasHelpers
  let eventHelpers: EventAPIHelpers

  test.beforeEach(async ({ page }) => {
    canvasHelpers = new CanvasHelpers(page)
    eventHelpers = new EventAPIHelpers(page)
    
    await canvasHelpers.initializeCanvas()
    await canvasHelpers.focusCanvas()
  })

  test('should handle API unavailability gracefully [E2E-CV-ERROR-01]', async ({ page }) => {
    // Test ID: E2E-CV-ERROR-01
    // PRD Reference: Canvas should continue to function when API is unavailable
    
    // Mock network failure for event API
    await page.route('/api/events', route => route.abort('failed'))
    
    // Canvas should still be functional for local operations
    const initialViewBox = await canvasHelpers.getViewBox()
    
    // Perform operations - they should work locally even if API fails
    await canvasHelpers.panCanvas({ x: 50, y: 50 })
    await page.waitForTimeout(200)
    
    const finalViewBox = await canvasHelpers.getViewBox()
    expect(finalViewBox.x).not.toBe(initialViewBox.x)
    expect(finalViewBox.y).not.toBe(initialViewBox.y)
    
    // Canvas should remain responsive
    expect(finalViewBox.width).toBeGreaterThan(0)
    expect(finalViewBox.height).toBeGreaterThan(0)
  })

  test('should show error messages for API failures [E2E-CV-ERROR-02]', async ({ page }) => {
    // Test ID: E2E-CV-ERROR-02
    // PRD Reference: Users should be informed of system errors
    
    // Mock API error responses
    await page.route('/api/events', route => \n      route.fulfill({ status: 500, body: 'Internal Server Error' })\n    )\n    \n    // Perform operation that would trigger API call\n    await canvasHelpers.panCanvas({ x: 100, y: 0 })\n    await page.waitForTimeout(500)\n    \n    // Look for error indicators in UI\n    const errorMessage = page.locator('[data-testid*=\"error\"], .error, [class*=\"error\"], [role=\"alert\"]')\n    const errorText = page.locator('text=/error|failed|unavailable/i')\n    \n    // Some form of error indication should be present\n    const hasErrorIndication = await errorMessage.count() > 0 || await errorText.count() > 0\n    \n    // If no visual error, at least console should log the error\n    // (This would be checked via console event listeners in beforeEach)\n    expect(hasErrorIndication).toBeTruthy()\n  })\n\n  test('should retry failed operations [E2E-CV-ERROR-03]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-03\n    // PRD Reference: System should attempt to recover from transient errors\n    \n    let requestCount = 0\n    \n    // Mock API to fail first request, succeed on retry\n    await page.route('/api/events', route => {\n      requestCount++\n      if (requestCount === 1) {\n        route.abort('failed')\n      } else {\n        route.continue()\n      }\n    })\n    \n    // Perform operation\n    await canvasHelpers.panCanvas({ x: 25, y: 25 })\n    await page.waitForTimeout(1000)\n    \n    // Should have made multiple attempts\n    expect(requestCount).toBeGreaterThan(1)\n  })\n\n  test('should handle malformed API responses [E2E-CV-ERROR-04]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-04\n    // PRD Reference: System should handle invalid data gracefully\n    \n    // Mock API to return invalid JSON\n    await page.route('/api/events', route => \n      route.fulfill({ \n        status: 200, \n        contentType: 'application/json',\n        body: '{ invalid json }'\n      })\n    )\n    \n    // Canvas should still function despite API returning bad data\n    const initialViewBox = await canvasHelpers.getViewBox()\n    \n    await canvasHelpers.zoomCanvas('in', 1)\n    await page.waitForTimeout(200)\n    \n    const zoomedViewBox = await canvasHelpers.getViewBox()\n    expect(zoomedViewBox.width).toBeLessThan(initialViewBox.width)\n    \n    // UI should remain responsive\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n  })\n})\n\ntest.describe('Canvas Component - Input Validation and Error Prevention', () => {\n  let canvasHelpers: CanvasHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    await canvasHelpers.initializeCanvas()\n  })\n\n  test('should handle invalid coordinate inputs [E2E-CV-ERROR-05]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-05\n    // PRD Reference: System should validate and sanitize inputs\n    \n    // Attempt to inject invalid coordinates through URL manipulation or direct API calls\n    // This simulates potential security/validation issues\n    \n    const canvas = canvasHelpers.getCanvas()\n    \n    // Try to set invalid viewBox through DOM manipulation\n    await canvas.evaluate(el => {\n      try {\n        // Attempt invalid viewBox values\n        (el as SVGElement).setAttribute('viewBox', 'invalid invalid invalid invalid')\n      } catch (e) {\n        // Expected to catch errors\n      }\n    })\n    \n    // Canvas should recover and maintain valid state\n    await page.waitForTimeout(200)\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n    expect(isNaN(viewBox.x)).toBe(false)\n    expect(isNaN(viewBox.y)).toBe(false)\n  })\n\n  test('should prevent extreme zoom values [E2E-CV-ERROR-06]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-06\n    // PRD Reference: System should prevent values that could crash the browser\n    \n    // Attempt extreme zoom operations that could cause issues\n    const canvas = canvasHelpers.getCanvas()\n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    // Simulate massive wheel events\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    \n    // Try to zoom to extreme levels\n    for (let i = 0; i < 50; i++) {\n      await page.mouse.wheel(0, -1000) // Large negative delta\n      await page.waitForTimeout(10)\n    }\n    \n    const extremeZoomViewBox = await canvasHelpers.getViewBox()\n    \n    // Should be constrained to reasonable limits\n    expect(extremeZoomViewBox.width).toBeGreaterThan(1) // Not microscopic\n    expect(extremeZoomViewBox.height).toBeGreaterThan(1)\n    expect(extremeZoomViewBox.width).toBeLessThan(50000) // Not massive\n    expect(extremeZoomViewBox.height).toBeLessThan(50000)\n  })\n\n  test('should handle rapid input without memory leaks [E2E-CV-ERROR-07]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-07\n    // PRD Reference: System should handle stress testing without degradation\n    \n    // Monitor initial memory if available\n    const initialMemory = await page.evaluate(() => {\n      // @ts-ignore\n      return performance.memory ? performance.memory.usedJSHeapSize : 0\n    })\n    \n    // Generate rapid events\n    for (let i = 0; i < 100; i++) {\n      await canvasHelpers.panCanvas({ x: i % 10, y: (i * 2) % 10 })\n      \n      // Small delay to prevent overwhelming\n      if (i % 10 === 0) {\n        await page.waitForTimeout(50)\n      }\n    }\n    \n    // Force garbage collection if available\n    await page.evaluate(() => {\n      // @ts-ignore\n      if (window.gc) window.gc()\n    })\n    \n    const finalMemory = await page.evaluate(() => {\n      // @ts-ignore\n      return performance.memory ? performance.memory.usedJSHeapSize : 0\n    })\n    \n    // Memory growth should be reasonable\n    if (initialMemory > 0 && finalMemory > 0) {\n      const memoryGrowth = finalMemory - initialMemory\n      expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024) // Less than 50MB growth\n    }\n    \n    // Canvas should still be responsive\n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n  })\n\n  test('should recover from temporary freeze/hang [E2E-CV-ERROR-08]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-08\n    // PRD Reference: System should recover from temporary performance issues\n    \n    // Simulate a scenario that might cause temporary hang\n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    // Generate intensive operations\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    \n    // Rapid zoom and pan simultaneously\n    const operations = []\n    for (let i = 0; i < 20; i++) {\n      operations.push(page.mouse.wheel(0, i % 2 === 0 ? -200 : 200))\n      operations.push(page.mouse.move(bounds.centerX + i, bounds.centerY + i))\n    }\n    \n    // Execute all operations simultaneously\n    await Promise.all(operations)\n    \n    // Wait for system to stabilize\n    await page.waitForTimeout(1000)\n    \n    // Canvas should recover and be responsive\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(isNaN(finalViewBox.x)).toBe(false)\n    expect(isNaN(finalViewBox.y)).toBe(false)\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n  })\n})\n\ntest.describe('Canvas Component - Browser Compatibility and Edge Cases', () => {\n  let canvasHelpers: CanvasHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    await canvasHelpers.initializeCanvas()\n  })\n\n  test('should handle viewport resize during operations [E2E-CV-ERROR-09]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-09\n    // PRD Reference: Canvas should adapt to container resize\n    \n    // Start a pan operation\n    const bounds = await canvasHelpers.getCanvasBounds()\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    \n    // Resize viewport during operation\n    await page.setViewportSize({ width: 800, height: 600 })\n    await page.waitForTimeout(100)\n    \n    // Complete the operation\n    await page.mouse.move(bounds.centerX + 50, bounds.centerY + 50)\n    await page.mouse.up()\n    \n    // Canvas should handle resize gracefully\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n  })\n\n  test('should handle focus loss during interactions [E2E-CV-ERROR-10]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-10\n    // PRD Reference: Canvas should handle focus changes gracefully\n    \n    await canvasHelpers.focusCanvas()\n    \n    // Start keyboard pan\n    await page.keyboard.down('ArrowRight')\n    \n    // Simulate focus loss (e.g., user clicks elsewhere)\n    await page.click('body')\n    \n    // Release key after focus loss\n    await page.keyboard.up('ArrowRight')\n    \n    // Canvas should not get stuck in key-down state\n    await canvasHelpers.focusCanvas()\n    \n    // Normal operation should work\n    const initialViewBox = await canvasHelpers.getViewBox()\n    await page.keyboard.press('ArrowLeft')\n    await page.waitForTimeout(100)\n    \n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.x).not.toBe(initialViewBox.x)\n  })\n\n  test('should handle disabled JavaScript scenarios [E2E-CV-ERROR-11]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-11\n    // PRD Reference: Canvas should degrade gracefully without JavaScript\n    \n    // This test is challenging as Playwright requires JS, but we can test\n    // the initial render state and static elements\n    \n    const canvas = canvasHelpers.getCanvas()\n    const canvasContainer = page.locator(CANVAS_SELECTORS.canvas)\n    \n    // Basic elements should be present\n    await expect(canvasContainer).toBeVisible()\n    await expect(canvas).toBeVisible()\n    \n    // Should have proper semantic markup\n    await expect(canvas).toHaveAttribute('role', 'img')\n    \n    // Should have accessibility attributes\n    const ariaLabel = await canvasContainer.getAttribute('aria-label')\n    expect(ariaLabel).toBeTruthy()\n  })\n\n  test('should handle concurrent user sessions [E2E-CV-ERROR-12]', async ({ page, browser }) => {\n    // Test ID: E2E-CV-ERROR-12\n    // PRD Reference: Multiple users should not interfere with each other\n    \n    // Create a second browser context (simulating different user)\n    const secondContext = await browser.newContext()\n    const secondPage = await secondContext.newPage()\n    const secondCanvasHelpers = new CanvasHelpers(secondPage)\n    \n    try {\n      await secondCanvasHelpers.initializeCanvas()\n      \n      // Both canvases should function independently\n      await canvasHelpers.panCanvas({ x: 50, y: 0 })\n      await secondCanvasHelpers.panCanvas({ x: -50, y: 0 })\n      \n      await page.waitForTimeout(200)\n      \n      // Both should have different states\n      const firstViewBox = await canvasHelpers.getViewBox()\n      const secondViewBox = await secondCanvasHelpers.getViewBox()\n      \n      // States should be independent\n      expect(firstViewBox.x).not.toBe(secondViewBox.x)\n      \n      // Both should be valid\n      expect(firstViewBox.width).toBeGreaterThan(0)\n      expect(secondViewBox.width).toBeGreaterThan(0)\n      \n    } finally {\n      await secondContext.close()\n    }\n  })\n\n  test('should handle malicious input attempts [E2E-CV-ERROR-13]', async ({ page }) => {\n    // Test ID: E2E-CV-ERROR-13\n    // PRD Reference: System should be resilient to malicious input\n    \n    const canvas = canvasHelpers.getCanvas()\n    \n    // Attempt to inject scripts or malicious content\n    await canvas.evaluate(el => {\n      try {\n        // Attempt various injection attacks\n        (el as any).setAttribute('onload', 'alert(\"xss\")')\n        (el as any).setAttribute('data-malicious', '<script>alert(\"xss\")</script>')\n        \n        // Attempt to modify critical attributes\n        (el as any).setAttribute('viewBox', 'javascript:alert(\"xss\")')\n      } catch (e) {\n        // Expected to be blocked or sanitized\n      }\n    })\n    \n    // System should remain stable\n    await page.waitForTimeout(200)\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n    \n    // No alerts should have been triggered\n    // (Playwright would throw if alert() was called)\n  })\n})"