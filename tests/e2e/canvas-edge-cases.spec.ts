import { test, expect } from '@playwright/test'
import { CanvasHelpers, EventAPIHelpers, PerformanceHelpers } from './helpers/canvas-helpers'
import { CANVAS_SELECTORS, CANVAS_CONFIG, performanceThresholds, viewports } from '../fixtures/canvas'

/**
 * E2E Tests for Canvas Edge Cases (Task 5.1)
 * Test ID: E2E-CV-EDGE
 * 
 * This test suite covers Canvas edge cases and boundary conditions:
 * - Extreme zoom levels and coordinates
 * - Performance with large numbers of operations
 * - Edge cases in user interactions
 * - Boundary conditions for all features
 * 
 * Following TDD approach - these tests will FAIL initially.
 */

test.describe('Canvas Component - Extreme Zoom and Coordinate Edge Cases', () => {
  let canvasHelpers: CanvasHelpers
  let eventHelpers: EventAPIHelpers

  test.beforeEach(async ({ page }) => {
    canvasHelpers = new CanvasHelpers(page)
    eventHelpers = new EventAPIHelpers(page)
    
    await canvasHelpers.initializeCanvas()
    await canvasHelpers.focusCanvas()
  })

  test('should handle maximum zoom levels [E2E-CV-EDGE-01]', async ({ page }) => {
    // Test ID: E2E-CV-EDGE-01\n    // PRD Reference: Canvas should handle extreme zoom without breaking\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    \n    // Zoom to absolute maximum\n    for (let i = 0; i < 50; i++) {\n      await page.mouse.wheel(0, -500)\n      await page.waitForTimeout(10)\n      \n      // Check if we've hit the limit\n      const viewBox = await canvasHelpers.getViewBox()\n      if (viewBox.width <= 1) break\n    }\n    \n    const maxZoomViewBox = await canvasHelpers.getViewBox()\n    \n    // Should not break the canvas\n    expect(maxZoomViewBox.width).toBeGreaterThan(0)\n    expect(maxZoomViewBox.height).toBeGreaterThan(0)\n    expect(isFinite(maxZoomViewBox.x)).toBe(true)\n    expect(isFinite(maxZoomViewBox.y)).toBe(true)\n    \n    // Should still be able to zoom out\n    await page.mouse.wheel(0, 500)\n    await page.waitForTimeout(100)\n    \n    const zoomedOutViewBox = await canvasHelpers.getViewBox()\n    expect(zoomedOutViewBox.width).toBeGreaterThan(maxZoomViewBox.width)\n  })\n\n  test('should handle minimum zoom levels [E2E-CV-EDGE-02]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-02\n    // PRD Reference: Canvas should handle maximum zoom out without issues\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    \n    // Zoom to absolute minimum\n    for (let i = 0; i < 50; i++) {\n      await page.mouse.wheel(0, 500)\n      await page.waitForTimeout(10)\n      \n      // Check if we've hit the limit\n      const viewBox = await canvasHelpers.getViewBox()\n      if (viewBox.width >= 50000) break\n    }\n    \n    const minZoomViewBox = await canvasHelpers.getViewBox()\n    \n    // Should not break the canvas\n    expect(minZoomViewBox.width).toBeLessThan(100000) // Reasonable maximum\n    expect(minZoomViewBox.height).toBeLessThan(100000)\n    expect(isFinite(minZoomViewBox.x)).toBe(true)\n    expect(isFinite(minZoomViewBox.y)).toBe(true)\n    \n    // Canvas should still be usable\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n  })\n\n  test('should handle extreme coordinate values [E2E-CV-EDGE-03]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-03\n    // PRD Reference: Canvas should handle large coordinate spaces\n    \n    // Pan to extreme coordinates\n    for (let i = 0; i < 100; i++) {\n      await canvasHelpers.panCanvas({ x: 100, y: 100 })\n      await page.waitForTimeout(10)\n      \n      // Check if we've reached boundaries\n      const viewBox = await canvasHelpers.getViewBox()\n      if (Math.abs(viewBox.x) >= CANVAS_CONFIG.pan.boundary) break\n    }\n    \n    const extremeViewBox = await canvasHelpers.getViewBox()\n    \n    // Should handle extreme coordinates gracefully\n    expect(isFinite(extremeViewBox.x)).toBe(true)\n    expect(isFinite(extremeViewBox.y)).toBe(true)\n    expect(extremeViewBox.width).toBeGreaterThan(0)\n    expect(extremeViewBox.height).toBeGreaterThan(0)\n    \n    // Should still be able to navigate back\n    await canvasHelpers.resetView()\n    await page.waitForTimeout(200)\n    \n    const resetViewBox = await canvasHelpers.getViewBox()\n    expect(Math.abs(resetViewBox.x)).toBeLessThan(Math.abs(extremeViewBox.x))\n  })\n\n  test('should handle fractional coordinates precisely [E2E-CV-EDGE-04]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-04\n    // PRD Reference: Canvas should handle sub-pixel precision\n    \n    // Perform precise fractional movements\n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    \n    // Move by fractional pixels\n    await page.mouse.move(\n      bounds.centerX + 0.5,\n      bounds.centerY + 0.7,\n      { steps: 1 }\n    )\n    await page.mouse.up()\n    \n    await page.waitForTimeout(100)\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    \n    // Coordinates should remain valid\n    expect(isFinite(viewBox.x)).toBe(true)\n    expect(isFinite(viewBox.y)).toBe(true)\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n  })\n})\n\ntest.describe('Canvas Component - Performance and Stress Edge Cases', () => {\n  let canvasHelpers: CanvasHelpers\n  let performanceHelpers: PerformanceHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    performanceHelpers = new PerformanceHelpers(page)\n    \n    await canvasHelpers.initializeCanvas()\n  })\n\n  test('should handle rapid successive operations [E2E-CV-EDGE-05]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-05\n    // PRD Reference: Canvas should handle burst operations smoothly\n    \n    const startTime = Date.now()\n    \n    // Generate burst of operations\n    const operations = []\n    \n    for (let i = 0; i < 50; i++) {\n      operations.push(async () => {\n        await canvasHelpers.panCanvas({ x: i % 5, y: (i * 2) % 5 })\n      })\n    }\n    \n    // Execute operations in rapid succession\n    await Promise.all(operations.map(op => op()))\n    \n    const endTime = Date.now()\n    const duration = endTime - startTime\n    \n    // Should complete reasonably quickly\n    expect(duration).toBeLessThan(performanceThresholds.timing.slowOperation)\n    \n    // Canvas should remain stable\n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n    expect(isFinite(finalViewBox.x)).toBe(true)\n    expect(isFinite(finalViewBox.y)).toBe(true)\n  })\n\n  test('should handle very long interaction sessions [E2E-CV-EDGE-06]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-06\n    // PRD Reference: Canvas should be stable during extended use\n    \n    const initialMemory = await page.evaluate(() => {\n      // @ts-ignore\n      return performance.memory ? performance.memory.usedJSHeapSize : 0\n    })\n    \n    // Simulate long session with varied operations\n    for (let session = 0; session < 10; session++) {\n      // Each session: pan, zoom, reset pattern\n      await canvasHelpers.panCanvas({ x: session * 10, y: session * 5 })\n      await canvasHelpers.zoomCanvas(session % 2 === 0 ? 'in' : 'out', 1)\n      \n      if (session % 3 === 0) {\n        await canvasHelpers.resetView()\n      }\n      \n      await page.waitForTimeout(50)\n    }\n    \n    // Force garbage collection\n    await page.evaluate(() => {\n      // @ts-ignore\n      if (window.gc) window.gc()\n    })\n    \n    const finalMemory = await page.evaluate(() => {\n      // @ts-ignore\n      return performance.memory ? performance.memory.usedJSHeapSize : 0\n    })\n    \n    // Memory growth should be reasonable\n    if (initialMemory > 0 && finalMemory > 0) {\n      const memoryGrowth = finalMemory - initialMemory\n      expect(memoryGrowth).toBeLessThan(10 * 1024 * 1024) // Less than 10MB\n    }\n    \n    // Canvas should still be responsive\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n  })\n\n  test('should handle simultaneous pan and zoom operations [E2E-CV-EDGE-07]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-07\n    // PRD Reference: Canvas should handle concurrent interactions\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    // Start pan operation\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    \n    // Simultaneously zoom while panning\n    const panPromise = page.mouse.move(\n      bounds.centerX + 100,\n      bounds.centerY + 100,\n      { steps: 10 }\n    )\n    \n    // Zoom while pan is in progress\n    const zoomPromise = (async () => {\n      for (let i = 0; i < 5; i++) {\n        await page.mouse.wheel(0, i % 2 === 0 ? -120 : 120)\n        await page.waitForTimeout(20)\n      }\n    })()\n    \n    await Promise.all([panPromise, zoomPromise])\n    await page.mouse.up()\n    \n    await page.waitForTimeout(200)\n    \n    // Canvas should handle concurrent operations\n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n    expect(isFinite(finalViewBox.x)).toBe(true)\n    expect(isFinite(finalViewBox.y)).toBe(true)\n  })\n\n  test('should handle operations during page transitions [E2E-CV-EDGE-08]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-08\n    // PRD Reference: Canvas should handle navigation gracefully\n    \n    // Start an operation\n    await canvasHelpers.panCanvas({ x: 50, y: 50 })\n    \n    // Simulate page transition attempt during operation\n    const navigationPromise = page.goto(page.url() + '?reload=true')\n    \n    // Continue operation during navigation\n    await canvasHelpers.zoomCanvas('in', 1)\n    \n    await navigationPromise\n    await page.waitForLoadState('networkidle')\n    \n    // Re-initialize after navigation\n    await canvasHelpers.initializeCanvas()\n    \n    // Canvas should be functional after navigation\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n  })\n})\n\ntest.describe('Canvas Component - Viewport and Responsive Edge Cases', () => {\n  let canvasHelpers: CanvasHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    await canvasHelpers.initializeCanvas()\n  })\n\n  test('should handle very small viewport sizes [E2E-CV-EDGE-09]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-09\n    // PRD Reference: Canvas should work on small screens\n    \n    // Set very small viewport\n    await page.setViewportSize({ width: 200, height: 150 })\n    await page.waitForTimeout(200)\n    \n    // Canvas should still be functional\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    expect(bounds.width).toBeGreaterThan(0)\n    expect(bounds.height).toBeGreaterThan(0)\n    \n    // Operations should still work\n    await canvasHelpers.panCanvas({ x: 10, y: 10 })\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n  })\n\n  test('should handle very large viewport sizes [E2E-CV-EDGE-10]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-10\n    // PRD Reference: Canvas should work on large screens\n    \n    // Set very large viewport (4K+)\n    await page.setViewportSize({ width: 4096, height: 2160 })\n    await page.waitForTimeout(300)\n    \n    // Canvas should scale appropriately\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    expect(bounds.width).toBeGreaterThan(1000) // Should use available space\n    expect(bounds.height).toBeGreaterThan(500)\n    \n    // Operations should work smoothly even at large sizes\n    const startTime = Date.now()\n    await canvasHelpers.panCanvas({ x: 100, y: 100 })\n    const endTime = Date.now()\n    \n    expect(endTime - startTime).toBeLessThan(500) // Should be responsive\n  })\n\n  test('should handle rapid viewport size changes [E2E-CV-EDGE-11]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-11\n    // PRD Reference: Canvas should adapt to dynamic resizing\n    \n    const viewportSizes = [\n      { width: 800, height: 600 },\n      { width: 1200, height: 800 },\n      { width: 400, height: 300 },\n      { width: 1600, height: 900 },\n      { width: 600, height: 400 }\n    ]\n    \n    for (const size of viewportSizes) {\n      await page.setViewportSize(size)\n      await page.waitForTimeout(100)\n      \n      // Canvas should remain functional\n      const canvas = canvasHelpers.getCanvas()\n      await expect(canvas).toBeVisible()\n      \n      const bounds = await canvasHelpers.getCanvasBounds()\n      expect(bounds.width).toBeGreaterThan(0)\n      expect(bounds.height).toBeGreaterThan(0)\n    }\n    \n    // Final functionality check\n    await canvasHelpers.panCanvas({ x: 25, y: 25 })\n    \n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n  })\n\n  test('should handle extreme aspect ratios [E2E-CV-EDGE-12]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-12\n    // PRD Reference: Canvas should work with unusual aspect ratios\n    \n    const extremeAspectRatios = [\n      { width: 2000, height: 100 }, // Very wide\n      { width: 100, height: 1000 }, // Very tall\n      { width: 1920, height: 200 }, // Ultra-wide\n      { width: 300, height: 1200 }  // Ultra-tall\n    ]\n    \n    for (const size of extremeAspectRatios) {\n      await page.setViewportSize(size)\n      await page.waitForTimeout(200)\n      \n      // Canvas should adapt to extreme ratios\n      const canvas = canvasHelpers.getCanvas()\n      await expect(canvas).toBeVisible()\n      \n      const bounds = await canvasHelpers.getCanvasBounds()\n      expect(bounds.width).toBeGreaterThan(0)\n      expect(bounds.height).toBeGreaterThan(0)\n      \n      // ViewBox should maintain valid aspect ratio\n      const viewBox = await canvasHelpers.getViewBox()\n      const aspectRatio = viewBox.width / viewBox.height\n      expect(aspectRatio).toBeGreaterThan(0)\n      expect(isFinite(aspectRatio)).toBe(true)\n    }\n  })\n})\n\ntest.describe('Canvas Component - Interaction Edge Cases', () => {\n  let canvasHelpers: CanvasHelpers\n\n  test.beforeEach(async ({ page }) => {\n    canvasHelpers = new CanvasHelpers(page)\n    await canvasHelpers.initializeCanvas()\n  })\n\n  test('should handle mouse events at canvas boundaries [E2E-CV-EDGE-13]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-13\n    // PRD Reference: Canvas should handle edge interactions\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    // Test interactions at each corner\n    const corners = [\n      { x: bounds.x + 1, y: bounds.y + 1 }, // Top-left\n      { x: bounds.x + bounds.width - 1, y: bounds.y + 1 }, // Top-right\n      { x: bounds.x + 1, y: bounds.y + bounds.height - 1 }, // Bottom-left\n      { x: bounds.x + bounds.width - 1, y: bounds.y + bounds.height - 1 } // Bottom-right\n    ]\n    \n    for (const corner of corners) {\n      await page.mouse.move(corner.x, corner.y)\n      await page.mouse.down()\n      await page.mouse.move(corner.x + 10, corner.y + 10)\n      await page.mouse.up()\n      \n      await page.waitForTimeout(50)\n      \n      // Canvas should handle edge interactions\n      const viewBox = await canvasHelpers.getViewBox()\n      expect(viewBox.width).toBeGreaterThan(0)\n      expect(viewBox.height).toBeGreaterThan(0)\n    }\n  })\n\n  test('should handle interrupted drag operations [E2E-CV-EDGE-14]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-14\n    // PRD Reference: Canvas should recover from interrupted interactions\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    \n    // Start drag operation\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    \n    // Interrupt with keyboard or focus change\n    await page.keyboard.press('Escape')\n    \n    // Try to continue drag (should not affect anything)\n    await page.mouse.move(bounds.centerX + 100, bounds.centerY + 100)\n    \n    // Canvas should not be stuck in drag state\n    const canvas = canvasHelpers.getCanvas()\n    const cursor = await canvas.evaluate(el => \n      window.getComputedStyle(el).cursor\n    )\n    \n    // Should not be in grabbing/dragging cursor state\n    expect(cursor).not.toMatch(/grabbing/)\n    \n    // Mouse up should complete normally\n    await page.mouse.up()\n    \n    // Canvas should be responsive to new operations\n    await canvasHelpers.panCanvas({ x: 10, y: 10 })\n    \n    const viewBox = await canvasHelpers.getViewBox()\n    expect(viewBox.width).toBeGreaterThan(0)\n    expect(viewBox.height).toBeGreaterThan(0)\n  })\n\n  test('should handle zero-distance drag operations [E2E-CV-EDGE-15]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-15\n    // PRD Reference: Canvas should handle micro-movements\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    const initialViewBox = await canvasHelpers.getViewBox()\n    \n    // Perform zero-distance drag (click without movement)\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    await page.mouse.up()\n    \n    await page.waitForTimeout(100)\n    \n    // ViewBox should be unchanged\n    const afterClickViewBox = await canvasHelpers.getViewBox()\n    expect(Math.abs(afterClickViewBox.x - initialViewBox.x)).toBeLessThan(1)\n    expect(Math.abs(afterClickViewBox.y - initialViewBox.y)).toBeLessThan(1)\n    \n    // Perform micro-movement drag\n    await page.mouse.move(bounds.centerX, bounds.centerY)\n    await page.mouse.down()\n    await page.mouse.move(bounds.centerX + 0.1, bounds.centerY + 0.1)\n    await page.mouse.up()\n    \n    await page.waitForTimeout(100)\n    \n    // Should handle micro-movements without issues\n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n    expect(isFinite(finalViewBox.x)).toBe(true)\n    expect(isFinite(finalViewBox.y)).toBe(true)\n  })\n\n  test('should handle rapid click sequences [E2E-CV-EDGE-16]', async ({ page }) => {\n    // Test ID: E2E-CV-EDGE-16\n    // PRD Reference: Canvas should handle rapid user input\n    \n    const bounds = await canvasHelpers.getCanvasBounds()\n    const startTime = Date.now()\n    \n    // Rapid click sequence\n    for (let i = 0; i < 20; i++) {\n      await page.mouse.click(\n        bounds.centerX + (i % 5) * 10,\n        bounds.centerY + (i % 4) * 10\n      )\n      await page.waitForTimeout(10)\n    }\n    \n    const endTime = Date.now()\n    const duration = endTime - startTime\n    \n    // Should handle rapid clicks without significant delay\n    expect(duration).toBeLessThan(1000)\n    \n    // Canvas should remain responsive\n    const canvas = canvasHelpers.getCanvas()\n    await expect(canvas).toBeVisible()\n    \n    // Normal operations should still work\n    await canvasHelpers.panCanvas({ x: 15, y: 15 })\n    \n    const finalViewBox = await canvasHelpers.getViewBox()\n    expect(finalViewBox.width).toBeGreaterThan(0)\n    expect(finalViewBox.height).toBeGreaterThan(0)\n  })\n})"