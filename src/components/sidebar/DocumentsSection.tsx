/**\n * Documents Section Component (Task 8.3)\n * \n * Specialized section component for displaying document objects\n * with document-specific metadata, file type filtering, and size information.\n */\n\nimport React, { useMemo } from 'react'\nimport { FileText } from 'lucide-react'\nimport { SidebarSection } from './SidebarSection'\nimport { \n  DocumentItem, \n  SidebarSectionConfig,\n  FilterOption,\n  SearchConfig,\n  SidebarFactory \n} from '../../../schemas/api/sidebar'\n\ninterface DocumentsSectionProps {\n  items?: DocumentItem[]\n  config?: Partial<SidebarSectionConfig>\n  isCollapsed?: boolean\n  onStateChange?: (state: any) => void\n  onItemSelect?: (item: DocumentItem) => void\n  onItemDrag?: (item: DocumentItem, event: React.DragEvent) => void\n}\n\nexport const DocumentsSection: React.FC<DocumentsSectionProps> = ({\n  items = [],\n  config = {},\n  isCollapsed = false,\n  onStateChange,\n  onItemSelect,\n  onItemDrag\n}) => {\n  // Default configuration for documents section\n  const sectionConfig: SidebarSectionConfig = useMemo(() => ({\n    id: 'documents',\n    title: 'Documents',\n    icon: 'file-text',\n    isCollapsed: false,\n    isVisible: true,\n    order: 1,\n    enableVirtualization: true,\n    enableSearch: true,\n    enableFilters: true,\n    ...config\n  }), [config])\n  \n  // Search configuration for documents\n  const searchConfig: SearchConfig = useMemo(() => \n    SidebarFactory.createSearchConfig({\n      searchFields: ['name', 'description', 'tags', 'author'],\n      placeholder: 'Search documents...'\n    }), []\n  )\n  \n  // Filter options specific to documents\n  const filterOptions: FilterOption[] = useMemo(() => {\n    const statusOptions = [...new Set(items.map(item => item.metadata.status))]\n      .map(status => ({ \n        value: status, \n        label: status.charAt(0).toUpperCase() + status.slice(1),\n        count: items.filter(item => item.metadata.status === status).length\n      }))\n    \n    const typeOptions = [...new Set(items.map(item => item.metadata.type))]\n      .map(type => ({ \n        value: type, \n        label: type.toUpperCase(),\n        count: items.filter(item => item.metadata.type === type).length\n      }))\n    \n    const sizeRanges = [\n      { value: '0-1mb', label: 'Under 1 MB', count: 0 },\n      { value: '1-10mb', label: '1-10 MB', count: 0 },\n      { value: '10-100mb', label: '10-100 MB', count: 0 },\n      { value: '100mb+', label: 'Over 100 MB', count: 0 }\n    ]\n    \n    // Calculate file size distribution\n    items.forEach(item => {\n      const size = item.metadata.size || 0\n      const sizeMB = size / (1024 * 1024)\n      \n      if (sizeMB < 1) sizeRanges[0].count++\n      else if (sizeMB < 10) sizeRanges[1].count++\n      else if (sizeMB < 100) sizeRanges[2].count++\n      else sizeRanges[3].count++\n    })\n    \n    const allTags = [...new Set(items.flatMap(item => item.metadata.tags || []))]\n    const tagOptions = allTags.map(tag => ({\n      value: tag,\n      label: tag,\n      count: items.filter(item => item.metadata.tags?.includes(tag)).length\n    }))\n    \n    const allAuthors = [...new Set(items.map(item => item.metadata.author).filter(Boolean))]\n    const authorOptions = allAuthors.map(author => ({\n      value: author,\n      label: author,\n      count: items.filter(item => item.metadata.author === author).length\n    }))\n    \n    return [\n      {\n        key: 'type',\n        label: 'File Type',\n        type: 'multiselect' as const,\n        options: typeOptions,\n        defaultValue: [],\n        isVisible: true,\n        isRequired: false,\n        order: 0\n      },\n      {\n        key: 'status',\n        label: 'Status',\n        type: 'multiselect' as const,\n        options: statusOptions,\n        defaultValue: [],\n        isVisible: true,\n        isRequired: false,\n        order: 1\n      },\n      {\n        key: 'size',\n        label: 'File Size',\n        type: 'select' as const,\n        options: sizeRanges.filter(range => range.count > 0),\n        defaultValue: null,\n        isVisible: items.some(item => item.metadata.size),\n        isRequired: false,\n        order: 2\n      },\n      {\n        key: 'author',\n        label: 'Author',\n        type: 'multiselect' as const,\n        options: authorOptions.slice(0, 20), // Limit to prevent UI clutter\n        defaultValue: [],\n        isVisible: authorOptions.length > 0,\n        isRequired: false,\n        order: 3\n      },\n      {\n        key: 'tags',\n        label: 'Tags',\n        type: 'multiselect' as const,\n        options: tagOptions.slice(0, 20),\n        defaultValue: [],\n        isVisible: tagOptions.length > 0,\n        isRequired: false,\n        order: 4\n      },\n      {\n        key: 'isReadOnly',\n        label: 'Read-Only Documents Only',\n        type: 'boolean' as const,\n        defaultValue: false,\n        isVisible: items.some(item => item.metadata.isReadOnly),\n        isRequired: false,\n        order: 5\n      },\n      {\n        key: 'lastModified',\n        label: 'Last Modified',\n        type: 'daterange' as const,\n        defaultValue: null,\n        isVisible: true,\n        isRequired: false,\n        order: 6\n      }\n    ]\n  }, [items])\n  \n  // Handle item selection with document-specific logic\n  const handleItemSelect = (item: any) => {\n    const documentItem = item as DocumentItem\n    onItemSelect?.(documentItem)\n  }\n  \n  // Handle drag start with document-specific data\n  const handleItemDrag = (item: any, event: React.DragEvent) => {\n    const documentItem = item as DocumentItem\n    onItemDrag?.(documentItem, event)\n  }\n  \n  // Calculate section statistics\n  const stats = useMemo(() => {\n    const totalDocs = items.length\n    const publishedDocs = items.filter(item => item.metadata.status === 'published').length\n    const draftDocs = items.filter(item => item.metadata.status === 'draft').length\n    const totalSize = items.reduce((sum, item) => sum + (item.metadata.size || 0), 0)\n    const avgSize = totalDocs > 0 ? totalSize / totalDocs : 0\n    const totalWords = items.reduce((sum, item) => sum + (item.metadata.wordCount || 0), 0)\n    \n    // File type distribution\n    const typeDistribution = items.reduce((acc, item) => {\n      acc[item.metadata.type] = (acc[item.metadata.type] || 0) + 1\n      return acc\n    }, {} as Record<string, number>)\n    \n    return {\n      total: totalDocs,\n      published: publishedDocs,\n      drafts: draftDocs,\n      totalSize,\n      avgSize,\n      totalWords,\n      typeDistribution\n    }\n  }, [items])\n  \n  return (\n    <SidebarSection\n      config={sectionConfig}\n      items={items}\n      isCollapsed={isCollapsed}\n      searchConfig={searchConfig}\n      onStateChange={(state) => {\n        // Add documents-specific state information\n        const enhancedState = {\n          ...state,\n          stats,\n          filterOptions\n        }\n        onStateChange?.(enhancedState)\n      }}\n      onItemSelect={handleItemSelect}\n      onItemDrag={handleItemDrag}\n    />\n  )\n}\n\nexport default DocumentsSection