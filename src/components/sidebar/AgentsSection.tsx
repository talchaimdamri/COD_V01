/**\n * Agents Section Component (Task 8.3)\n * \n * Specialized section component for displaying agent objects\n * with agent-specific metadata, model filtering, and performance metrics.\n */\n\nimport React, { useMemo } from 'react'\nimport { Bot } from 'lucide-react'\nimport { SidebarSection } from './SidebarSection'\nimport { \n  AgentItem, \n  SidebarSectionConfig,\n  FilterOption,\n  SearchConfig,\n  SidebarFactory \n} from '../../../schemas/api/sidebar'\n\ninterface AgentsSectionProps {\n  items?: AgentItem[]\n  config?: Partial<SidebarSectionConfig>\n  isCollapsed?: boolean\n  onStateChange?: (state: any) => void\n  onItemSelect?: (item: AgentItem) => void\n  onItemDrag?: (item: AgentItem, event: React.DragEvent) => void\n}\n\nexport const AgentsSection: React.FC<AgentsSectionProps> = ({\n  items = [],\n  config = {},\n  isCollapsed = false,\n  onStateChange,\n  onItemSelect,\n  onItemDrag\n}) => {\n  // Default configuration for agents section\n  const sectionConfig: SidebarSectionConfig = useMemo(() => ({\n    id: 'agents',\n    title: 'Agents',\n    icon: 'bot',\n    isCollapsed: false,\n    isVisible: true,\n    order: 2,\n    enableVirtualization: true,\n    enableSearch: true,\n    enableFilters: true,\n    ...config\n  }), [config])\n  \n  // Search configuration for agents\n  const searchConfig: SearchConfig = useMemo(() => \n    SidebarFactory.createSearchConfig({\n      searchFields: ['name', 'description', 'tags', 'model', 'capabilities'],\n      placeholder: 'Search agents...'\n    }), []\n  )\n  \n  // Filter options specific to agents\n  const filterOptions: FilterOption[] = useMemo(() => {\n    const statusOptions = [...new Set(items.map(item => item.metadata.status))]\n      .map(status => ({ \n        value: status, \n        label: status.charAt(0).toUpperCase() + status.slice(1),\n        count: items.filter(item => item.metadata.status === status).length\n      }))\n    \n    const modelOptions = [...new Set(items.map(item => item.metadata.model))]\n      .map(model => ({ \n        value: model, \n        label: model,\n        count: items.filter(item => item.metadata.model === model).length\n      }))\n    \n    const providerOptions = [...new Set(items.map(item => item.metadata.provider).filter(Boolean))]\n      .map(provider => ({ \n        value: provider!, \n        label: provider!.charAt(0).toUpperCase() + provider!.slice(1),\n        count: items.filter(item => item.metadata.provider === provider).length\n      }))\n    \n    // Performance tiers based on success rate\n    const performanceTiers = [\n      { value: 'high', label: 'High Performance (>90%)', count: 0 },\n      { value: 'medium', label: 'Medium Performance (70-90%)', count: 0 },\n      { value: 'low', label: 'Low Performance (<70%)', count: 0 },\n      { value: 'no-data', label: 'No Performance Data', count: 0 }\n    ]\n    \n    items.forEach(item => {\n      const successRate = item.metadata.performance?.successRate\n      if (!successRate) {\n        performanceTiers[3].count++\n      } else if (successRate > 0.9) {\n        performanceTiers[0].count++\n      } else if (successRate > 0.7) {\n        performanceTiers[1].count++\n      } else {\n        performanceTiers[2].count++\n      }\n    })\n    \n    const allCapabilities = [...new Set(items.flatMap(item => item.metadata.capabilities || []))]\n    const capabilityOptions = allCapabilities.map(capability => ({\n      value: capability,\n      label: capability.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),\n      count: items.filter(item => item.metadata.capabilities?.includes(capability)).length\n    }))\n    \n    const allTags = [...new Set(items.flatMap(item => item.metadata.tags || []))]\n    const tagOptions = allTags.map(tag => ({\n      value: tag,\n      label: tag,\n      count: items.filter(item => item.metadata.tags?.includes(tag)).length\n    }))\n    \n    return [\n      {\n        key: 'status',\n        label: 'Status',\n        type: 'multiselect' as const,\n        options: statusOptions,\n        defaultValue: [],\n        isVisible: true,\n        isRequired: false,\n        order: 0\n      },\n      {\n        key: 'model',\n        label: 'AI Model',\n        type: 'multiselect' as const,\n        options: modelOptions,\n        defaultValue: [],\n        isVisible: true,\n        isRequired: false,\n        order: 1\n      },\n      {\n        key: 'provider',\n        label: 'Provider',\n        type: 'multiselect' as const,\n        options: providerOptions,\n        defaultValue: [],\n        isVisible: providerOptions.length > 0,\n        isRequired: false,\n        order: 2\n      },\n      {\n        key: 'performance',\n        label: 'Performance',\n        type: 'select' as const,\n        options: performanceTiers.filter(tier => tier.count > 0),\n        defaultValue: null,\n        isVisible: items.some(item => item.metadata.performance),\n        isRequired: false,\n        order: 3\n      },\n      {\n        key: 'capabilities',\n        label: 'Capabilities',\n        type: 'multiselect' as const,\n        options: capabilityOptions.slice(0, 20), // Limit to prevent UI clutter\n        defaultValue: [],\n        isVisible: capabilityOptions.length > 0,\n        isRequired: false,\n        order: 4\n      },\n      {\n        key: 'tags',\n        label: 'Tags',\n        type: 'multiselect' as const,\n        options: tagOptions.slice(0, 20),\n        defaultValue: [],\n        isVisible: tagOptions.length > 0,\n        isRequired: false,\n        order: 5\n      },\n      {\n        key: 'isShared',\n        label: 'Shared Agents Only',\n        type: 'boolean' as const,\n        defaultValue: false,\n        isVisible: items.some(item => item.metadata.isShared),\n        isRequired: false,\n        order: 6\n      },\n      {\n        key: 'isTemplate',\n        label: 'Template Agents Only',\n        type: 'boolean' as const,\n        defaultValue: false,\n        isVisible: items.some(item => item.metadata.isTemplate),\n        isRequired: false,\n        order: 7\n      },\n      {\n        key: 'lastUsed',\n        label: 'Last Used',\n        type: 'daterange' as const,\n        defaultValue: null,\n        isVisible: items.some(item => item.metadata.lastUsed),\n        isRequired: false,\n        order: 8\n      }\n    ]\n  }, [items])\n  \n  // Handle item selection with agent-specific logic\n  const handleItemSelect = (item: any) => {\n    const agentItem = item as AgentItem\n    onItemSelect?.(agentItem)\n  }\n  \n  // Handle drag start with agent-specific data\n  const handleItemDrag = (item: any, event: React.DragEvent) => {\n    const agentItem = item as AgentItem\n    onItemDrag?.(agentItem, event)\n  }\n  \n  // Calculate section statistics\n  const stats = useMemo(() => {\n    const totalAgents = items.length\n    const activeAgents = items.filter(item => item.metadata.status === 'idle' || item.metadata.status === 'processing').length\n    const processingAgents = items.filter(item => item.metadata.status === 'processing').length\n    const sharedAgents = items.filter(item => item.metadata.isShared).length\n    const templateAgents = items.filter(item => item.metadata.isTemplate).length\n    \n    // Model distribution\n    const modelDistribution = items.reduce((acc, item) => {\n      acc[item.metadata.model] = (acc[item.metadata.model] || 0) + 1\n      return acc\n    }, {} as Record<string, number>)\n    \n    // Provider distribution\n    const providerDistribution = items.reduce((acc, item) => {\n      const provider = item.metadata.provider || 'Unknown'\n      acc[provider] = (acc[provider] || 0) + 1\n      return acc\n    }, {} as Record<string, number>)\n    \n    // Average performance metrics\n    const agentsWithPerformance = items.filter(item => item.metadata.performance)\n    const avgSuccessRate = agentsWithPerformance.length > 0 \n      ? agentsWithPerformance.reduce((sum, item) => sum + (item.metadata.performance?.successRate || 0), 0) / agentsWithPerformance.length\n      : 0\n    \n    const avgResponseTime = agentsWithPerformance.length > 0 \n      ? agentsWithPerformance.reduce((sum, item) => sum + (item.metadata.performance?.averageResponseTime || 0), 0) / agentsWithPerformance.length\n      : 0\n    \n    const totalExecutions = items.reduce((sum, item) => sum + (item.metadata.performance?.totalExecutions || 0), 0)\n    \n    return {\n      total: totalAgents,\n      active: activeAgents,\n      processing: processingAgents,\n      shared: sharedAgents,\n      templates: templateAgents,\n      modelDistribution,\n      providerDistribution,\n      avgSuccessRate,\n      avgResponseTime,\n      totalExecutions\n    }\n  }, [items])\n  \n  return (\n    <SidebarSection\n      config={sectionConfig}\n      items={items}\n      isCollapsed={isCollapsed}\n      searchConfig={searchConfig}\n      onStateChange={(state) => {\n        // Add agents-specific state information\n        const enhancedState = {\n          ...state,\n          stats,\n          filterOptions\n        }\n        onStateChange?.(enhancedState)\n      }}\n      onItemSelect={handleItemSelect}\n      onItemDrag={handleItemDrag}\n    />\n  )\n}\n\nexport default AgentsSection