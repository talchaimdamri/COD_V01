/**\n * Chains Section Component (Task 8.3)\n * \n * Specialized section component for displaying chain objects\n * with chain-specific metadata and filtering options.\n */\n\nimport React, { useMemo } from 'react'\nimport { Link } from 'lucide-react'\nimport { SidebarSection } from './SidebarSection'\nimport { \n  ChainItem, \n  SidebarSectionConfig,\n  FilterOption,\n  SearchConfig,\n  SidebarFactory \n} from '../../../schemas/api/sidebar'\n\ninterface ChainsSectionProps {\n  items?: ChainItem[]\n  config?: Partial<SidebarSectionConfig>\n  isCollapsed?: boolean\n  onStateChange?: (state: any) => void\n  onItemSelect?: (item: ChainItem) => void\n  onItemDrag?: (item: ChainItem, event: React.DragEvent) => void\n}\n\nexport const ChainsSection: React.FC<ChainsSectionProps> = ({\n  items = [],\n  config = {},\n  isCollapsed = false,\n  onStateChange,\n  onItemSelect,\n  onItemDrag\n}) => {\n  // Default configuration for chains section\n  const sectionConfig: SidebarSectionConfig = useMemo(() => ({\n    id: 'chains',\n    title: 'Chains',\n    icon: 'link',\n    isCollapsed: false,\n    isVisible: true,\n    order: 0,\n    enableVirtualization: true,\n    enableSearch: true,\n    enableFilters: true,\n    ...config\n  }), [config])\n  \n  // Search configuration for chains\n  const searchConfig: SearchConfig = useMemo(() => \n    SidebarFactory.createSearchConfig({\n      searchFields: ['name', 'description', 'tags'],\n      placeholder: 'Search chains...'\n    }), []\n  )\n  \n  // Filter options specific to chains\n  const filterOptions: FilterOption[] = useMemo(() => {\n    const statusOptions = [...new Set(items.map(item => item.metadata.status))]\n      .map(status => ({ \n        value: status, \n        label: status.charAt(0).toUpperCase() + status.slice(1),\n        count: items.filter(item => item.metadata.status === status).length\n      }))\n    \n    const nodeCountRanges = [\n      { value: '0-5', label: '1-5 nodes', count: 0 },\n      { value: '6-10', label: '6-10 nodes', count: 0 },\n      { value: '11-20', label: '11-20 nodes', count: 0 },\n      { value: '21+', label: '21+ nodes', count: 0 }\n    ]\n    \n    // Calculate node count distribution\n    items.forEach(item => {\n      const nodeCount = item.metadata.nodeCount\n      if (nodeCount <= 5) nodeCountRanges[0].count++\n      else if (nodeCount <= 10) nodeCountRanges[1].count++\n      else if (nodeCount <= 20) nodeCountRanges[2].count++\n      else nodeCountRanges[3].count++\n    })\n    \n    const allTags = [...new Set(items.flatMap(item => item.metadata.tags || []))]\n    const tagOptions = allTags.map(tag => ({\n      value: tag,\n      label: tag,\n      count: items.filter(item => item.metadata.tags?.includes(tag)).length\n    }))\n    \n    return [\n      {\n        key: 'status',\n        label: 'Status',\n        type: 'multiselect' as const,\n        options: statusOptions,\n        defaultValue: [],\n        isVisible: true,\n        isRequired: false,\n        order: 0\n      },\n      {\n        key: 'nodeCount',\n        label: 'Node Count',\n        type: 'select' as const,\n        options: nodeCountRanges.filter(range => range.count > 0),\n        defaultValue: null,\n        isVisible: true,\n        isRequired: false,\n        order: 1\n      },\n      {\n        key: 'tags',\n        label: 'Tags',\n        type: 'multiselect' as const,\n        options: tagOptions.slice(0, 20), // Limit to prevent UI clutter\n        defaultValue: [],\n        isVisible: tagOptions.length > 0,\n        isRequired: false,\n        order: 2\n      },\n      {\n        key: 'isTemplate',\n        label: 'Template Chains Only',\n        type: 'boolean' as const,\n        defaultValue: false,\n        isVisible: items.some(item => item.metadata.isTemplate),\n        isRequired: false,\n        order: 3\n      },\n      {\n        key: 'lastModified',\n        label: 'Last Modified',\n        type: 'daterange' as const,\n        defaultValue: null,\n        isVisible: true,\n        isRequired: false,\n        order: 4\n      }\n    ]\n  }, [items])\n  \n  // Handle item selection with chain-specific logic\n  const handleItemSelect = (item: any) => {\n    // Type assertion since we know this is a ChainItem\n    const chainItem = item as ChainItem\n    onItemSelect?.(chainItem)\n  }\n  \n  // Handle drag start with chain-specific data\n  const handleItemDrag = (item: any, event: React.DragEvent) => {\n    const chainItem = item as ChainItem\n    onItemDrag?.(chainItem, event)\n  }\n  \n  // Calculate section statistics\n  const stats = useMemo(() => {\n    const totalChains = items.length\n    const activeChains = items.filter(item => item.metadata.status === 'active').length\n    const templateChains = items.filter(item => item.metadata.isTemplate).length\n    const totalNodes = items.reduce((sum, item) => sum + item.metadata.nodeCount, 0)\n    const avgNodesPerChain = totalChains > 0 ? Math.round(totalNodes / totalChains) : 0\n    \n    return {\n      total: totalChains,\n      active: activeChains,\n      templates: templateChains,\n      totalNodes,\n      avgNodesPerChain\n    }\n  }, [items])\n  \n  return (\n    <SidebarSection\n      config={sectionConfig}\n      items={items}\n      isCollapsed={isCollapsed}\n      searchConfig={searchConfig}\n      onStateChange={(state) => {\n        // Add chains-specific state information\n        const enhancedState = {\n          ...state,\n          stats,\n          filterOptions\n        }\n        onStateChange?.(enhancedState)\n      }}\n      onItemSelect={handleItemSelect}\n      onItemDrag={handleItemDrag}\n    />\n  )\n}\n\nexport default ChainsSection